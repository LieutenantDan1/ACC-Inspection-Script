{"version":"0.2.0","body":"const DOC_INFO = new Map<string, string>([\n    [\"Document\", \"PDN-F01\"],\n    [\"Revision\", \"3\"],\n    [\"Date\", \"2023-06-30\"]\n]);\n\nconst SPC_DOC_INFO = new Map<string, string>([\n    [\"Document\", \"PDN-F02\"],\n    [\"Revision\", \"4\"],\n    [\"Date\", \"2023-06-30\"]\n]);\n\nconst DOC_INFO_POS = \"A1\";\nconst INFO_POS = \"A5\";\nconst INSP_POS = \"D1\";\n\nconst DOC_INFO_POS_INSP_SHEET = \"A1\";\nconst COMM_POS_INSP_SHEET = \"A5\";\nconst INFO_POS_INSP_SHEET = \"A12\";\nconst INSP_POS_INSP_SHEET = \"D1\";\n\nconst STD_INSPECTION_INFO = [\n    \"Customer\",\n    \"Part Name\",\n    \"Part Number\",\n    \"Revision\",\n    \"Inspection Level\",\n    \"Job Number\",\n    \"PO Number\",\n    \"Inspector\",\n    \"Date\",\n    \"Lot Size\",\n    \"Sample Size\",\n    \"Accepted\",\n    \"Rejected\"\n];\n\n// The first of these should be the most important one as it's part of the header\nconst STD_DIMENSION_INFO = [\n    \"Dimension\",\n    \"ID\",\n    \"Gauge ID\",\n    \"Maximum\",\n    \"Nominal\",\n    \"Minimum\",\n];\n\nenum SampleSize {\n    A = 2,\n    B = 3,\n    C = 5,\n    D = 8,\n    E = 13,\n    F = 20,\n    G = 32,\n    H = 50,\n    J = 80,\n    K = 125,\n    L = 200,\n    M = 315,\n    N = 500,\n    P = 800,\n    Q = 1250,\n    R = 2000,\n};\n\nconst INSP_LEVEL_1: [number, number][] = [\n    [8, SampleSize.A],\n    [15, SampleSize.A],\n    [25, SampleSize.B],\n    [50, SampleSize.C],\n    [90, SampleSize.C],\n    [150, SampleSize.D],\n    [280, SampleSize.E],\n    [500, SampleSize.F],\n    [1200, SampleSize.G],\n    [3200, SampleSize.H],\n    [10000, SampleSize.J],\n    [35000, SampleSize.K],\n    [150000, SampleSize.L],\n    [500000, SampleSize.M],\n    [Infinity, SampleSize.N]\n];\nconst INSP_LEVEL_2: [number, number][] = [\n    [8, SampleSize.A],\n    [15, SampleSize.B],\n    [25, SampleSize.C],\n    [50, SampleSize.D],\n    [90, SampleSize.E],\n    [150, SampleSize.F],\n    [280, SampleSize.G],\n    [500, SampleSize.H],\n    [1200, SampleSize.J],\n    [3200, SampleSize.K],\n    [10000, SampleSize.L],\n    [35000, SampleSize.M],\n    [150000, SampleSize.N],\n    [500000, SampleSize.P],\n    [Infinity, SampleSize.Q]\n];\nconst INSP_LEVEL_3: [number, number][] = [\n    [8, SampleSize.B],\n    [15, SampleSize.C],\n    [25, SampleSize.D],\n    [50, SampleSize.E],\n    [90, SampleSize.F],\n    [150, SampleSize.G],\n    [280, SampleSize.H],\n    [500, SampleSize.J],\n    [1200, SampleSize.K],\n    [3200, SampleSize.L],\n    [10000, SampleSize.M],\n    [35000, SampleSize.N],\n    [150000, SampleSize.P],\n    [500000, SampleSize.Q],\n    [Infinity, SampleSize.R]\n]\nconst INSP_LEVEL_S1: [number, number][] = [\n    [8, SampleSize.A],\n    [15, SampleSize.A],\n    [25, SampleSize.A],\n    [50, SampleSize.A],\n    [90, SampleSize.B],\n    [150, SampleSize.B],\n    [280, SampleSize.B],\n    [500, SampleSize.B],\n    [1200, SampleSize.C],\n    [3200, SampleSize.C],\n    [10000, SampleSize.C],\n    [35000, SampleSize.C],\n    [150000, SampleSize.D],\n    [500000, SampleSize.D],\n    [Infinity, SampleSize.D]\n];\nconst INSP_LEVEL_S2: [number, number][] = [\n    [8, SampleSize.A],\n    [15, SampleSize.A],\n    [25, SampleSize.A],\n    [50, SampleSize.B],\n    [90, SampleSize.B],\n    [150, SampleSize.B],\n    [280, SampleSize.C],\n    [500, SampleSize.C],\n    [1200, SampleSize.C],\n    [3200, SampleSize.D],\n    [10000, SampleSize.D],\n    [35000, SampleSize.D],\n    [150000, SampleSize.E],\n    [500000, SampleSize.E],\n    [Infinity, SampleSize.E]\n];\nconst INSP_LEVEL_S3: [number, number][] = [\n    [8, SampleSize.A],\n    [15, SampleSize.A],\n    [25, SampleSize.B],\n    [50, SampleSize.B],\n    [90, SampleSize.C],\n    [150, SampleSize.C],\n    [280, SampleSize.D],\n    [500, SampleSize.D],\n    [1200, SampleSize.E],\n    [3200, SampleSize.E],\n    [10000, SampleSize.F],\n    [35000, SampleSize.F],\n    [150000, SampleSize.G],\n    [500000, SampleSize.G],\n    [Infinity, SampleSize.H]\n];\nconst INSP_LEVEL_S4: [number, number][] = [\n    [8, SampleSize.A],\n    [15, SampleSize.A],\n    [25, SampleSize.B],\n    [50, SampleSize.C],\n    [90, SampleSize.C],\n    [150, SampleSize.D],\n    [280, SampleSize.E],\n    [500, SampleSize.E],\n    [1200, SampleSize.F],\n    [3200, SampleSize.G],\n    [10000, SampleSize.G],\n    [35000, SampleSize.H],\n    [150000, SampleSize.J],\n    [500000, SampleSize.J],\n    [Infinity, SampleSize.K]\n];\n\nconst INSPECTION_LEVELS = new Map<string, [number, number][]>([\n    [\"I (General)\", INSP_LEVEL_1],\n    [\"II (General)\", INSP_LEVEL_2],\n    [\"III (General)\", INSP_LEVEL_3],\n    [\"S-1 (Special)\", INSP_LEVEL_S1],\n    [\"S-2 (Special)\", INSP_LEVEL_S2],\n    [\"S-3 (Special)\", INSP_LEVEL_S3],\n    [\"S-4 (Special)\", INSP_LEVEL_S4]\n]);\n\nconst DV_ERROR = {\n    title: \"\",\n    message: \"Invalid value (choose one from the dropdown).\",\n    showAlert: true,\n    style: ExcelScript.DataValidationAlertStyle.stop,\n}\n\nenum Alignment {\n    left,\n    center,\n    right,\n    top,\n    bottom,\n}\n\nclass Style {\n    hAlign: Alignment;\n    vAlign: Alignment;\n    autofitCol: boolean;\n    autofitRow: boolean;\n    fontName: string;\n    fontBold: boolean;\n    fontColor: string;\n    wrapText: boolean;\n    fillColor: string;\n    borderStyles: ExcelScript.BorderLineStyle[];\n    borderWeights: ExcelScript.BorderWeight[];\n\n    constructor(init?: Partial<Style>) {\n        Object.assign(this, init);\n    }\n\n    // Apply everything that is not undefined in this style to <range>.\n    // Border styles/weights are applied as follows: edgeTop, edgeBottom, edgeLeft, edgeRight, insideVertical, insideHorizontal.\n    applyTo(fmt: ExcelScript.RangeFormat) {\n        if (this.wrapText != undefined) {\n            fmt.setWrapText(false);\n        }\n        let font = fmt.getFont();\n        let fill = fmt.getFill();\n        let borders = new Array<ExcelScript.RangeBorder>(6);\n        borders[0] = fmt.getRangeBorder(ExcelScript.BorderIndex.edgeTop);\n        borders[1] = fmt.getRangeBorder(ExcelScript.BorderIndex.edgeBottom);\n        borders[2] = fmt.getRangeBorder(ExcelScript.BorderIndex.edgeLeft);\n        borders[3] = fmt.getRangeBorder(ExcelScript.BorderIndex.edgeRight);\n        borders[4] = fmt.getRangeBorder(ExcelScript.BorderIndex.insideVertical);\n        borders[5] = fmt.getRangeBorder(ExcelScript.BorderIndex.insideHorizontal);\n        if (this.hAlign != undefined) {\n            // I can't assign the alignment directly because Office Scripts won't let me.\n            switch (this.hAlign) {\n                case Alignment.left:\n                    fmt.setHorizontalAlignment(ExcelScript.HorizontalAlignment.left);\n                    break;\n                case Alignment.center:\n                    fmt.setHorizontalAlignment(ExcelScript.HorizontalAlignment.center);\n                    break;\n                case Alignment.right:\n                    fmt.setHorizontalAlignment(ExcelScript.HorizontalAlignment.right);\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (this.vAlign != undefined) {\n            switch (this.vAlign) {\n                case Alignment.top:\n                    fmt.setVerticalAlignment(ExcelScript.VerticalAlignment.top);\n                    break;\n                case Alignment.center:\n                    fmt.setVerticalAlignment(ExcelScript.VerticalAlignment.center);\n                    break;\n                case Alignment.bottom:\n                    fmt.setVerticalAlignment(ExcelScript.VerticalAlignment.bottom);\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (this.fontName != undefined) {\n            font.setName(this.fontName);\n        }\n        if (this.fontBold != undefined) {\n            font.setBold(this.fontBold);\n        }\n        if (this.fontColor != undefined) {\n            font.setColor(this.fontColor);\n        }\n        if (this.fillColor != undefined) {\n            fill.setColor(this.fillColor);\n        }\n        if (this.borderStyles != undefined) {\n            let n = Math.min(this.borderStyles.length, borders.length);\n            for (let i = 0; i < n; ++i) {\n                if (this.borderStyles[i] != undefined) {\n                    borders[i].setStyle(this.borderStyles[i]);\n                }\n            }\n        }\n        if (this.borderWeights != undefined) {\n            let n = Math.min(this.borderWeights.length, borders.length);\n            for (let i = 0; i < n; ++i) {\n                if (this.borderWeights[i] != undefined) {\n                    borders[i].setWeight(this.borderWeights[i]);\n                }\n            }\n        }\n        if (this.autofitCol) {\n            fmt.autofitColumns();\n        }\n        if (this.autofitRow) {\n            fmt.autofitRows();\n        }\n        if (this.wrapText != undefined) {\n            fmt.setWrapText(this.wrapText);\n        }\n        return fmt;\n    }\n}\n\nconst DEFAULT_BORDER_STYLES = [\n    ExcelScript.BorderLineStyle.continuous,\n    ExcelScript.BorderLineStyle.continuous,\n    ExcelScript.BorderLineStyle.continuous,\n    ExcelScript.BorderLineStyle.continuous,\n    ExcelScript.BorderLineStyle.continuous,\n    ExcelScript.BorderLineStyle.continuous,\n];\n\nconst DEFAULT_BORDER_WEIGHTS = [\n    ExcelScript.BorderWeight.thick,\n    ExcelScript.BorderWeight.thick,\n    ExcelScript.BorderWeight.thick,\n    ExcelScript.BorderWeight.thick,\n    ExcelScript.BorderWeight.thin,\n    ExcelScript.BorderWeight.thin,\n];\n\nconst INFO_STYLE = new Style({\n    hAlign: Alignment.center,\n    autofitCol: true,\n    autofitRow: true,\n});\n\nconst DARK_BLUE = new Style({\n    hAlign: Alignment.center,\n    vAlign: Alignment.center,\n    autofitCol: true,\n    autofitRow: true,\n    fontName: \"Daytona Condensed\",\n    fontColor: \"FFFFFF\",\n    fontBold: false,\n    fillColor: \"305496\",\n    borderStyles: DEFAULT_BORDER_STYLES,\n    borderWeights: DEFAULT_BORDER_WEIGHTS,\n});\n\nconst MEDIUM_BLUE = new Style({\n    hAlign: Alignment.center,\n    vAlign: Alignment.center,\n    autofitCol: true,\n    autofitRow: true,\n    fontName: \"Daytona Condensed\",\n    fontColor: \"FFFFFF\",\n    fontBold: true,\n    fillColor: \"4472C4\",\n    borderStyles: DEFAULT_BORDER_STYLES,\n    borderWeights: DEFAULT_BORDER_WEIGHTS,\n});\n\nconst LIGHT_BLUE = new Style({\n    hAlign: Alignment.center,\n    vAlign: Alignment.center,\n    autofitCol: true,\n    autofitRow: true,\n    fontName: \"Daytona Condensed\",\n    fontColor: \"000000\",\n    fontBold: false,\n    fillColor: \"8EA9DB\",\n    borderStyles: DEFAULT_BORDER_STYLES,\n    borderWeights: DEFAULT_BORDER_WEIGHTS,\n});\n\nfunction columnLabel(i: number): string {\n    let label: number[] = [];\n    while (i >= 26) {\n        label.push(65 + i % 26);\n        i = Math.floor(i / 26) - 1;\n    }\n    label.push(65 + i);\n    return String.fromCodePoint.apply(null, label.reverse());\n}\n\nfunction cellLabel(range: ExcelScript.Range): string {\n    return columnLabel(range.getColumnIndex()) + (range.getRowIndex() + 1).toString();\n}\n\n// Expand the columns in <range> such that the total width of all columns in <range> is at least <minWidth>.\n// If the total width is greater than <minWidth> already, this function does nothing.\nfunction expandColumnsTo(range: ExcelScript.Range, minWidth: number) {\n    let n = range.getColumnCount();\n    let actWidth = 0;\n    let colWidths = new Array<number>(n);\n    let colFmts = new Array<ExcelScript.RangeFormat>(n);\n    for (let i = 0; i < n; ++i) {\n        let col = range.getColumn(i);\n        let fmt = col.getFormat();\n        let width = fmt.getColumnWidth();\n        colFmts[i] = fmt;\n        colWidths[i] = width;\n        actWidth += width;\n    }\n    let expand = (minWidth - actWidth) / n;\n    if (expand <= 0)\n        return;\n    for (let i = 0; i < n; ++i) {\n        colFmts[i].setColumnWidth(colWidths[i] + expand);\n    }\n}\n\nfunction expandLeft(range: ExcelScript.Range, n: number): ExcelScript.Range {\n    if (n === 0)\n        return range;\n    let nCols = range.getColumnCount();\n    n += nCols;\n    if (n === 0)\n        return undefined;\n    return range.getColumnsAfter(-n);\n}\n\nfunction expandRight(range: ExcelScript.Range, n: number): ExcelScript.Range {\n    if (n === 0)\n        return range;\n    let nCols = range.getColumnCount();\n    n += nCols;\n    if (n === 0)\n        return undefined;\n    return range.getColumnsBefore(-n);\n}\n\nfunction expandUp(range: ExcelScript.Range, n: number): ExcelScript.Range {\n    if (n === 0)\n        return range;\n    let nRows = range.getRowCount();\n    n += nRows;\n    if (n === 0)\n        return undefined;\n    return range.getRowsBelow(-n);\n}\n\nfunction expandDown(range: ExcelScript.Range, n: number): ExcelScript.Range {\n    if (n === 0)\n        return range;\n    let nRows = range.getRowCount();\n    n += nRows;\n    if (n === 0)\n        return undefined;\n    return range.getRowsAbove(-n);\n}\n\nfunction findAll(re: RegExp, s: string): [string, number][] {\n    let matches: [string, number][] = [];\n    let m: RegExpExecArray;\n    while ((m = re.exec(s)) != null) {\n        if (m.index === re.lastIndex) {\n            re.lastIndex++;\n        }\n        m.forEach(match => {\n            matches.push([match, m.index]);\n        });\n    }\n    return matches;\n}\n\n// Trim and remove extra characters after a number string\nconst numRe = /-?(?:\\d+\\.\\d*|\\.?\\d+)/gm;\nfunction sanitizeNumber(num: string): string {\n    numRe.lastIndex = 0;\n    let m = numRe.exec(num);\n    if (m != null) {\n        return num.substr(m.index, m[0].length);\n    }\n    return null;\n}\n\n// Return the number of fractional digits a number has.\nfunction numFractional(num: string): number {\n    let i = 0;\n    for (; i < num.length; ++i) {\n        if (num[i] === \".\") {\n            ++i;\n            break;\n        }\n    }\n    return num.length - i;\n}\n\n// Starting at the top-left cell of <range>, expand down until an empty cell is encountered (it is not included).\n// Then, expand right one column (so that the returned range has 2 columns).\n// If the range is undefined or its top left cell is empty, this function returns undefined.\nfunction getVerticalMapRange(range: ExcelScript.Range): ExcelScript.Range {\n    if (range == undefined)\n        return undefined;\n    range = range.getCell(0, 0);\n    if (range.getUsedRange(true) == undefined)\n        return undefined;\n    if (range.getRowsBelow(1).getUsedRange(true) != undefined)\n        range = range.getExtendedRange(ExcelScript.KeyboardDirection.down);\n    return expandRight(range, 1);\n}\n\n// Starting at the top-left cell of <range>, expand down until an empty cell is encountered (it is not included).\n// Then, expand right until an empty column is encountered (it is not included).\n// If the range is undefined or its top left cell is empty, this function returns undefined.\nfunction getVerticalMultiMapRange(range: ExcelScript.Range): ExcelScript.Range {\n    if (range == undefined || range.getCellCount() <= 0)\n        return undefined;\n\n    range = range.getCell(0, 0);\n\n    if (range.getUsedRange(true) == undefined)\n        return undefined;\n    \n    if (range.getRowsBelow(1).getUsedRange(true) != undefined)\n        range = range.getExtendedRange(ExcelScript.KeyboardDirection.down);\n    while (true) {\n        let next = expandRight(range, 1);\n        if (next.getLastColumn().getUsedRange(true) == undefined)\n            break;\n        range = next;\n    }\n    \n    return range;\n}\n\nfunction readVerticalMultiMap(range: ExcelScript.Range): Map<string, string>[] {\n    range = getVerticalMultiMapRange(range.getCell(0, 0));\n    if (range == undefined || range.getColumnCount() == 1)\n        return [];\n\n    let keys = range.getColumn(0).getTexts().map(x => x[0]);\n    range = expandLeft(range, -1);\n    let maps = new Array<Map<string, string>>(range.getColumnCount());\n    for (let i = 0; i < maps.length; ++i)\n        maps[i] = new Map<string, string>();\n    range.getTexts().forEach((x, i) => {\n        x.forEach((v, j) => {\n            maps[j].set(keys[i], v);\n        });\n    });\n\n    return maps;\n}\n\nfunction readVerticalMap(range: ExcelScript.Range): Map<string, string> {\n    range = getVerticalMapRange(range.getCell(0, 0));\n    let map = new Map<string, string>();\n    if (range == undefined)\n        return map;\n    let texts = range.getTexts();\n    texts.forEach(kvp => {\n        map.set(kvp[0], kvp[1]);\n    });\n    return map;\n}\n\n// If <x> contains a string enclosed by square brackets, return a tuple with:\n//     - <x> ending at the first square bracket (excluding the bracket itself)\n//     - the string contained within the square brackets\n// Otherwise, return undefined.\nfunction getOptions(x: string): [string, string] {\n    const optRegex = /\\[.*\\]/gm;\n    let m = optRegex.exec(x);\n    if (m == null || m.length == 0)\n        return undefined;\n    x = x.substring(0, m.index).trim();\n    let options = m[0].substr(1, m[0].length - 2);\n    return [x, options];\n}\n\n// Read the vertical map at <range>. Return said map with values overriden by those in <defaults> (only if the value in <defaults> is not empty).\n// If a key in <defaults> has comma separated options in square brackets (see getOptions), set the data validation in the corresponding value cell to only accept those options and remove the options from the key.\nfunction unionMaps(range: ExcelScript.Range, defaults: Map<string, string>): Map<string, string> {\n    let existing = readVerticalMap(range) ?? new Map<string, string>();\n    let map = new Map<string, string>();\n\n    defaults.forEach((v, k) => {\n        let options = getOptions(k);\n        if (options != undefined) {\n            let dv = range.getCell(map.size, 1).getDataValidation();\n            dv.clear();\n            dv.setRule({\n                list: {inCellDropDown: true, source: options[1]}\n            });\n            dv.setErrorAlert(DV_ERROR);\n            k = options[0];\n        }\n        if (v.length !== 0)\n            map.set(k, v);\n        else\n            map.set(k, existing.get(k) ?? \"\");\n        existing.delete(k);\n    });\n    existing.forEach((v, k) => {\n        map.set(k, v);\n    });\n\n    return map;\n}\n\nfunction writeVerticalMap(range: ExcelScript.Range, map: Map<string, string>, keysStyle: Style, valuesStyle: Style): ExcelScript.Range {\n    range = expandRight(expandDown(range.getCell(0, 0), map.size - 1), 1);\n    range.setNumberFormat(\"@\");\n    let entries = Array.from(map.entries());\n    for (let i = 0; i < entries.length; ++i) {\n        let options = getOptions(entries[i][0]);\n        if (options == undefined)\n            continue;\n        entries[i][0] = options[0];\n        let dv = range.getColumn(1).getCell(i, 0).getDataValidation();\n        dv.clear();\n        dv.setRule({\n            list: { inCellDropDown: true, source: options[1] }\n        });\n        dv.setErrorAlert(DV_ERROR);\n    }\n    range.setValues(entries);\n\n    let keysFmt = range.getColumn(0).getFormat();\n    let valuesFmt = range.getColumn(1).getFormat();\n\n    keysFmt.setHorizontalAlignment(ExcelScript.HorizontalAlignment.center);\n    valuesFmt.setHorizontalAlignment(ExcelScript.HorizontalAlignment.center);\n\n    if (keysStyle != undefined)\n        keysStyle.applyTo(keysFmt);\n    if (valuesStyle != undefined)\n        valuesStyle.applyTo(valuesFmt);\n    \n    keysFmt.autofitColumns();\n    valuesFmt.autofitColumns();\n\n    return range;\n}\n\nfunction writeMergedVerticalMap(keyRange: ExcelScript.Range, valRange: ExcelScript.Range, map: Map<string, string>, keyStyle: Style, valStyle: Style) {\n    keyRange = expandDown(keyRange, map.size - keyRange.getRowCount());\n    valRange = expandDown(valRange, map.size - valRange.getRowCount());\n\n    keyRange.merge(true);\n    valRange.merge(true);\n\n    let keyFmt = keyRange.getFormat();\n    let valFmt = valRange.getFormat();\n\n    if (keyStyle != undefined)\n        keyStyle.applyTo(keyFmt);\n    if (valStyle != undefined)\n        valStyle.applyTo(valFmt);\n    \n    keyRange.getColumnsBefore(-1).setValues(Array.from(map.keys()).map(x => [x]));\n    valRange.getColumnsBefore(-1).setValues(Array.from(map.values()).map(x => [x]));\n}\n\nfunction writeEmptyVerticalMap(range: ExcelScript.Range, keys: string[], keysStyle: Style, valuesStyle: Style) {\n    range = expandRight(expandDown(range.getCell(0, 0), keys.length - 1), 1);\n    range.setNumberFormat(\"@\");\n    range.setValues(keys.map(x => [x, null]));\n\n    if (keysStyle != undefined)\n        keysStyle.applyTo(range.getColumn(0).getFormat());\n    if (valuesStyle != undefined)\n        valuesStyle.applyTo(range.getColumn(1).getFormat());\n\n    return range;\n}\n\nfunction createCommentsBox(range: ExcelScript.Range) {\n    let topRow = range.getRow(0);\n    topRow.merge();\n    topRow.setValue(\"Comments\");\n    MEDIUM_BLUE.applyTo(topRow.getFormat());\n\n    let box = expandUp(range, -1);\n    let boxFmt = box.getFormat();\n    box.merge();\n    LIGHT_BLUE.applyTo(box.getFormat());\n    boxFmt.setWrapText(true);\n    boxFmt.setHorizontalAlignment(ExcelScript.HorizontalAlignment.left);\n    boxFmt.setVerticalAlignment(ExcelScript.VerticalAlignment.top);\n}\n\n// Basically range from Python.\nfunction range(start: number, stop: number, step: number): number[] {\n    let nums: number[] = [];\n    if (start > stop) {\n        if (step >= 0)\n            return undefined;\n        for (let i = start - 1; i >= stop; i += step)\n            nums.push(i);\n    }\n    else {\n        if (step <= 0)\n            return undefined;\n        for (let i = start; i < stop; i += step)\n            nums.push(i);\n    }\n    return nums;\n}\n\nfunction createPartInfo(workbook: ExcelScript.Workbook): ExcelScript.Worksheet {\n    let partInfo = workbook.addWorksheet(\"Part Info\");\n\n    writeVerticalMap(partInfo.getRange(DOC_INFO_POS), DOC_INFO, INFO_STYLE, INFO_STYLE);\n    let generalInfoValueRange = writeEmptyVerticalMap(partInfo.getRange(INFO_POS), STD_INSPECTION_INFO, INFO_STYLE, INFO_STYLE).getColumn(1);\n    \n    let inspLevelIdx = STD_INSPECTION_INFO.findIndex(v => v === \"Inspection Level\");\n    if (inspLevelIdx > -1) {\n        let dv = generalInfoValueRange.getCell(inspLevelIdx, 0).getDataValidation();\n        dv.clear();\n        let vals = \"\";\n        INSPECTION_LEVELS.forEach((v, k) => vals = vals.concat(\",\", k));\n        dv.setRule({\n            list: {inCellDropDown: true, source: vals},\n        });\n        dv.setErrorAlert(DV_ERROR);\n    }\n\n    let final = partInfo.getRange(INSP_POS);\n    final.setValue(\"Final Inspection\");\n    writeEmptyVerticalMap(final.getRowsBelow(1), STD_DIMENSION_INFO, INFO_STYLE, INFO_STYLE);\n\n    return partInfo;\n}\n\n// Return the union of all keys in <maps> as a string array.\nfunction unionKeys(maps: Map<string, string>[]): string[] {\n    let keySet = new Set<string>();\n    maps.forEach(m => {\n        m.forEach((v, k) => {\n            keySet.add(k);\n        })\n    });\n    return Array.from(keySet.values());\n}\n\n// Write the union of all the keys present in <dimensions> to the leftmost column of <range> (<range> will be expanded as needed starting from the top-left cell).\n// Write all values associated with the keys to subsequent columns, where each column corresponds to a map in <dimensions>. If a key does not have a value for a certain map, the cell is left blank.\n// Returns the column containing the unioned keys, or undefined if there are no keys (either <dimensions> is empty or contains only empty maps). If undefined is returned, <range>'s worksheet is not modified.\n// If old inspection data is present (identified by a '1' in the keys column), it is moved down to make room for the dimensions.\nfunction updateDimensions(range: ExcelScript.Range, dimensions: Map<string, string>[]): ExcelScript.Range {\n    let dimKeys = unionKeys(dimensions);\n    if (dimKeys.length == 0)\n        return undefined;\n\n    let dimKeyRange = range.getCell(0, 0);\n    if (dimKeys.length > 1)\n        dimKeyRange = dimKeyRange.getRowsAbove(-dimKeys.length);\n\n    let oldKeys = dimKeyRange.getTexts().map(x => x[0]);\n    for (let i = 0; i < oldKeys.length; ++i) {\n        if (oldKeys[i] == \"1\") {\n            // we have encountered old inspection data - move it down to make room for dimensions\n            let row = dimKeyRange.getRowIndex();\n            let col = dimKeyRange.getColumnIndex();\n\n            let oldDataRange = dimKeyRange.getCell(i, 0);\n            oldDataRange = getVerticalMultiMapRange(oldDataRange);\n            if (oldDataRange != undefined)\n                oldDataRange.moveTo(oldDataRange.getOffsetRange(dimKeys.length - i, 0));\n\n            // why the fuck does moving another range resize keyRange\n            dimKeyRange = range.getWorksheet().getRangeByIndexes(row, col, dimKeys.length, 1);\n        }\n    }\n\n    dimKeyRange.setValues(dimKeys.map(x => [x]));\n    MEDIUM_BLUE.applyTo(dimKeyRange.getFormat());\n\n    if (dimensions.length > 0) {\n        let dimRange = dimKeyRange.getColumnsAfter(dimensions.length);\n        dimRange.setNumberFormat(\"@\");\n        dimRange.setValues(dimKeys.map(k => dimensions.map(d => d.get(k) ?? \"\")));\n\n        DARK_BLUE.applyTo(dimRange.getFormat());\n        MEDIUM_BLUE.applyTo(dimRange.getRow(0).getFormat());\n    }\n\n    return dimKeyRange;\n}\n\nfunction setConditionalFormatting(sampleDataRange: ExcelScript.Range, dimensions: Map<string, string>[]) {\n    for (let i = 0; i < dimensions.length; ++i) {\n        let col = sampleDataRange.getColumn(i);\n        let colFmt = col.getFormat();\n\n        let min = sanitizeNumber(dimensions[i].get(\"Minimum\") ?? \"\");\n        let nom = sanitizeNumber(dimensions[i].get(\"Nominal\") ?? \"\");\n        let max = sanitizeNumber(dimensions[i].get(\"Maximum\") ?? \"\");\n\n        let prec = -1;\n        if (min != undefined) {\n            prec = Math.max(prec, numFractional(min));\n        }\n        if (nom != undefined) {\n            prec = Math.max(prec, numFractional(nom));\n        }\n        if (max != undefined) {\n            prec = Math.max(prec, numFractional(max));\n        }\n        if (prec < 0) {\n            col.setNumberFormat(\"@\");\n            continue;\n        }\n        let numFmt = \"0\";\n        if (prec > 0)\n            numFmt = numFmt.concat(\".\", \"0\".repeat(prec));\n        col.setNumberFormat(numFmt);\n\n        let label = cellLabel(col);\n        if (min == undefined && max != undefined) {\n            let cond = col.addConditionalFormat(ExcelScript.ConditionalFormatType.custom).getCustom();\n            cond.getRule().setFormula(`=ROUND(${label},${prec})<=${max}`);\n            cond.getFormat().getFill().setColor(\"80FF80\");\n            colFmt.getFill().setColor(\"FF8080\");\n        }\n        else if (min != undefined && max == undefined) {\n            let cond = col.addConditionalFormat(ExcelScript.ConditionalFormatType.custom).getCustom();\n            cond.getRule().setFormula(`=${min}<=ROUND(${label},${prec})`);\n            cond.getFormat().getFill().setColor(\"80FF80\");\n            colFmt.getFill().setColor(\"FF8080\");\n        }\n        else if (min != undefined && max != undefined) {\n            let cond = col.addConditionalFormat(ExcelScript.ConditionalFormatType.custom).getCustom();\n            cond.getRule().setFormula(`=AND(${min}<=ROUND(${label},${prec}),ROUND(${label},${prec})<=${max})`);\n            cond.getFormat().getFill().setColor(\"80FF80\");\n            colFmt.getFill().setColor(\"FF8080\");\n        }\n    }\n}\n\nfunction setYesNoCondFmt(range: ExcelScript.Range) {\n    range.setNumberFormat(\"@\");\n    let dv = range.getDataValidation();\n    dv.clear();\n    dv.setRule({\n        list: { inCellDropDown: true, source: \"✔,✘\" }\n    });\n    dv.setErrorAlert(DV_ERROR);\n    let cond = range.addConditionalFormat(ExcelScript.ConditionalFormatType.cellValue).getCellValue();\n    cond.setRule({\n        formula1: \"\\\"✔\\\"\",\n        operator: ExcelScript.ConditionalCellValueOperator.equalTo\n    });\n    cond.getFormat().getFill().setColor(\"80FF80\");\n    range.getFormat().getFill().setColor(\"FF8080\");\n}\n\nfunction getSampleSize(lotSize: number, inspLevel: string) {\n    let inspSampleSizes = INSPECTION_LEVELS.get(inspLevel);\n    if (inspSampleSizes == undefined)\n        return NaN;\n\n    let left = 0;\n    let right = inspSampleSizes.length;\n\n    while (left < right) {\n        let center = (left + right) >> 1;\n        if (lotSize <= inspSampleSizes[center][0])\n            right = center;\n        else\n            left = center + 1;\n    }\n\n    if (left < 0 || left >= inspSampleSizes.length)\n        return NaN;\n    return inspSampleSizes[left][1];\n}\n\nfunction updateInspection(header: ExcelScript.Range, inspName: string, sampleSize: number, dimensions: Map<string, string>[], defIndex: number, columnDefs: Map<string, string>): ExcelScript.Range {\n    header = header.getCell(0, 0);\n    header.setValue(inspName);\n    MEDIUM_BLUE.applyTo(header.getFormat());\n    let minHeaderWidth = header.getFormat().getColumnWidth();\n    header.clear();\n\n    let dimKeyRange = updateDimensions(header.getCell(1, 0), dimensions);\n    if (dimKeyRange == undefined)\n        dimKeyRange = header.getCell(1, 0);\n    let dimsIdx = dimKeyRange.getColumnIndex() + 1; // index of the leftmost column of dimension data\n    \n    if (!isNaN(sampleSize) && sampleSize > 0) {\n        let sampleNumRange = dimKeyRange.getRowsBelow(sampleSize);\n        sampleNumRange.setValues(range(0, sampleSize, 1).map(x => [x + 1]));\n        let passFailRange: ExcelScript.Range = undefined;\n\n        if (dimensions.length > 0) {\n            let sampleDataRange = sampleNumRange.getColumnsAfter(dimensions.length);\n            sampleDataRange.getDataValidation().clear();\n            passFailRange = sampleDataRange.getColumnsAfter(1);\n            let sampleDataFormat = sampleDataRange.getFormat();\n            sampleDataFormat.setHorizontalAlignment(ExcelScript.HorizontalAlignment.left);\n            LIGHT_BLUE.applyTo(sampleDataFormat);\n            setConditionalFormatting(sampleDataRange, dimensions);\n\n            let dataRow = (sampleDataRange.getRowIndex() + 1).toString();\n            for (let i = 0; i < dimensions.length; ++i) {\n                columnDefs.set(columnLabel(defIndex + i), columnLabel(dimsIdx + i) + dataRow);\n            }\n        }\n        else {\n            passFailRange = sampleNumRange.getColumnsAfter(1);\n            passFailRange.setFormula(\"\");\n            dimKeyRange.setValue(\"#\");\n            MEDIUM_BLUE.applyTo(dimKeyRange.getFormat());\n        }\n\n        let passFailDv = passFailRange.getDataValidation();\n        passFailDv.clear();\n        passFailDv.setRule({\n            list: { inCellDropDown: true, source: \"PASS,FAIL\" }\n        });\n        passFailDv.setErrorAlert(DV_ERROR);\n\n        let passFailCond = passFailRange.addConditionalFormat(ExcelScript.ConditionalFormatType.cellValue).getCellValue();\n        passFailCond.setRule({\n            formula1: \"\\\"PASS\\\"\",\n            operator: ExcelScript.ConditionalCellValueOperator.equalTo\n        });\n        passFailCond.getFormat().getFill().setColor(\"80FF80\");\n\n        let passFailHeader = passFailRange.getRowsAbove(1);\n        passFailHeader.setValue(\"PASS/FAIL\");\n\n        LIGHT_BLUE.applyTo(sampleNumRange.getFormat());\n        MEDIUM_BLUE.applyTo(passFailHeader.getFormat());\n        LIGHT_BLUE.applyTo(passFailRange.getFormat());\n        passFailRange.getFormat().getFill().setColor(\"FF8080\");\n    }\n\n    header = expandRight(header, dimensions.length + 1);\n    header.merge();\n    header.setValue(inspName);\n    MEDIUM_BLUE.applyTo(header.getFormat());\n    expandColumnsTo(header, minHeaderWidth);\n    return header.getCell(0, dimensions.length + 3);\n}\n\nfunction update(partInfoSheet: ExcelScript.Worksheet, inspSheet: ExcelScript.Worksheet, workbook: ExcelScript.Workbook) {\n    writeVerticalMap(inspSheet.getRange(DOC_INFO_POS_INSP_SHEET), DOC_INFO, MEDIUM_BLUE, LIGHT_BLUE);\n\n    let inspInfoPos = inspSheet.getRange(INFO_POS_INSP_SHEET);\n    let partInfo = unionMaps(inspInfoPos, readVerticalMap(partInfoSheet.getRange(INFO_POS)));\n\n    let lotSize = Number.parseInt(partInfo.get(\"Lot Size\"));\n    let sampleSize: number = NaN;\n    if (!isNaN(lotSize)) {\n        sampleSize = getSampleSize(lotSize, partInfo.get(\"Inspection Level\") ?? \"\");\n        if (!isNaN(sampleSize) && lotSize < sampleSize)\n            sampleSize = lotSize;\n    }\n    if (isNaN(sampleSize)) {\n        sampleSize = Number.parseInt(partInfo.get(\"Sample Size\"));\n    }\n    else {\n        partInfo.set(\"Sample Size\", sampleSize.toString());\n    }\n\n    let columnDefs = new Map<string, string>();\n    let formulae: [string, string][] = []; // [dest. column, formula]\n\n    let inspDefHeader = partInfoSheet.getRange(INSP_POS);\n    let inspHeader = inspSheet.getRange(INSP_POS_INSP_SHEET);\n    while (true) {\n        let inspName = inspDefHeader.getText();\n        if (inspName.length == 0)\n            break;\n        else {\n            let dimDefIdx = inspDefHeader.getColumnIndex() + 1;\n            let dimensions = readVerticalMultiMap(inspDefHeader.getRowsBelow(1));\n\n            for (let i = 0; i < dimensions.length; ++i) {\n                let option = getOptions(dimensions[i].get(\"Gauge ID\"));\n                if (option == null)\n                    continue;\n                dimensions[i].set(\"Gauge ID\", option[0]);\n                let formula = option[1].trim();\n                formulae.push([columnLabel(dimDefIdx + i), formula]);\n            }\n\n            inspDefHeader = inspDefHeader.getOffsetRange(0, dimensions.length + 2);\n            inspHeader = updateInspection(inspHeader, inspName, sampleSize, dimensions, dimDefIdx, columnDefs);\n        }\n    }\n\n    const colRe = /![A-Z]+/gm;\n    if (!isNaN(sampleSize) && sampleSize >= 1) {\n        for (let i = 0; i < formulae.length; ++i) {\n            let dest = columnDefs.get(formulae[i][0]);\n            if (dest == null)\n                continue;\n            let formula = formulae[i][1];\n            let destRangeTop = inspSheet.getRange(dest);\n            let destRange = expandDown(destRangeTop, sampleSize - 1);\n            if (formula.toLowerCase() === \"bool\") {\n                setYesNoCondFmt(destRange);\n            }\n            else {\n                if (!formula.startsWith(\"=\"))\n                    formula = \"=\" + formula;\n                formula = formula.replace(colRe, (match) => {\n                    return columnDefs.get(match.substring(1)) ?? \"\";\n                });\n                if (destRange.getNumberFormat() === \"@\")\n                    destRange.setNumberFormat(\"General\");\n                destRangeTop.setFormula(formula);\n                destRangeTop.autoFill(destRange, ExcelScript.AutoFillType.fillValues);\n            }\n        }\n    }\n\n    writeVerticalMap(inspSheet.getRange(INFO_POS_INSP_SHEET), partInfo, MEDIUM_BLUE, LIGHT_BLUE);\n    createCommentsBox(expandDown(expandRight(inspSheet.getRange(COMM_POS_INSP_SHEET), 1), 5));\n}\n\nfunction main(workbook: ExcelScript.Workbook) {\n    let partInfo = workbook.getWorksheet(\"Part Info\");\n    if (partInfo == undefined) {\n        partInfo = createPartInfo(workbook);\n        partInfo.activate();\n        return;\n    }\n\n    let inspSheet = workbook.getWorksheet(\"Inspection\") ?? workbook.addWorksheet(\"Inspection\");\n    let inspRange = inspSheet.getRange();\n    inspRange.clear(ExcelScript.ClearApplyTo.formats);\n    inspRange.getDataValidation().clear();\n    inspSheet.activate();\n    \n    update(partInfo, inspSheet, workbook);\n}","description":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}